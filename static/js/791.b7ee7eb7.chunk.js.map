{"version":3,"file":"static/js/791.b7ee7eb7.chunk.js","mappings":"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","sources":["services/L10n.ts","components/dashboard/TrainingCard.tsx","services/TrainingStatistics.ts","components/dashboard/Dashboard.tsx","services/TrainingService.ts"],"sourcesContent":["export function printTermWord(count: number){\n    if (count === 1)\n        return `${count} term`;\n\n    return `${count} terms`;\n}","import {getTrainingStatistics} from \"../../services/TrainingStatistics\";\nimport {CButton, CCard, CCardBody, CCardHeader, CCardText, CCardTitle, CCol} from \"@coreui/react\";\nimport {CChartRadar} from \"@coreui/react-chartjs\";\nimport {printTermWord} from \"../../services/L10n\";\nimport React, {FC, useEffect, useReducer} from \"react\";\nimport {TrainingDefinition} from \"../../model/TrainingDefinition\";\nimport {LepeatProfile} from \"../../model/LepeatProfile\";\nimport {useNavigate} from \"react-router-dom\";\nimport {TrainingType} from \"../../services/TrainingService\";\nimport { formatDistance } from 'date-fns'\n\n\nexport const TrainingCard : FC<{training: TrainingDefinition, profile: LepeatProfile}> = ({training, profile}) => {\n    const navigate = useNavigate();\n    const navigateToTraining = (name: string, trainingType: TrainingType) => {\n        navigate('/training_session', {\n            state: {\n                trainingName: name,\n                trainingType: trainingType\n            }\n        });\n    };\n\n    let {overallStatistics, thisTimeStatistics, minimalTimeToUpdate} = getTrainingStatistics(training, profile);\n    const termsToRepeat = thisTimeStatistics.slice(1).reduce((sum, value) => sum + value, 0);\n    const allTermsCount = overallStatistics.reduce((sum, num) => sum + num, 0);\n    const termsToLearn = thisTimeStatistics[0];\n\n    const [, forceUpdate] = useReducer(x => x + 1, 0);\n    useEffect(() => {\n        if (minimalTimeToUpdate > 2147483647){ //longer is not available according to the spec\n            return () => {};\n        }\n\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        minimalTimeToUpdate = Math.max(minimalTimeToUpdate, 10 * 1000); // do not update too often\n        minimalTimeToUpdate = Math.min(minimalTimeToUpdate, 2 * 60 * 1000); // update at least once in 2 minutes to keep \"Next training in\" up-to-date\n\n        const timerId = setTimeout(() => {\n            forceUpdate();\n        }, minimalTimeToUpdate);\n\n        return () => {\n            clearTimeout(timerId);\n        };\n    });\n\n    return (\n        <CCol sm={6} xl={4} xxl={3} key={training.name}>\n            <CCard className=\"mb-4\">\n                <CCardHeader>\n                    <CChartRadar\n                        data={{\n                            labels: ['Learning']\n                                .concat(Array.from(\n                                    {length: overallStatistics.length - 1},\n                                    (_, i) => `${i + 1} iteration`)),\n                            datasets: [\n                                {\n                                    label: 'Terms to train now',\n                                    backgroundColor: 'rgba(255, 99, 132, 0.2)',\n                                    borderColor: 'rgba(255, 99, 132, 1)',\n                                    pointBackgroundColor: 'rgba(255, 99, 132, 1)',\n                                    pointBorderColor: '#fff',\n                                    /*@ts-expect-error*/\n                                    pointHighlightFill: '#fff',\n                                    pointHighlightStroke: 'rgba(151, 187, 205, 1)',\n                                    data: thisTimeStatistics,\n                                },\n                                {\n                                    label: 'Terms on iteration',\n                                    backgroundColor: 'rgba(151, 187, 205, 0.2)',\n                                    borderColor: 'rgba(151, 187, 205, 1)',\n                                    pointBackgroundColor: 'rgba(151, 187, 205, 1)',\n                                    pointBorderColor: '#fff',\n                                    /*@ts-expect-error*/\n                                    pointHighlightFill: '#fff',\n                                    pointHighlightStroke: 'rgba(220, 220, 220, 1)',\n                                    data: overallStatistics,\n                                },\n                            ],\n                        }}\n                        options={{\n                            scales: {\n                                r: {\n                                    ticks: {\n                                        showLabelBackdrop: false, //remove white background around ticks\n                                        precision: 0, //do not allow fractional numbers\n                                        z: 1,\n                                    },\n                                }\n                            },\n                        }}\n                    />\n                </CCardHeader>\n                <CCardBody>\n                    <CCardTitle>{training.name}</CCardTitle>\n                    <CCardText>You have {printTermWord(termsToLearn)} to learn and {printTermWord(termsToRepeat)} to repeat ouf of {allTermsCount}.</CCardText>\n\n                    <div className=\"d-grid gap-2 col-10 mx-auto\">\n                        {termsToLearn > 0 && termsToRepeat > 0 ? (\n                            <>\n                                <CButton color=\"primary\"\n                                         onClick={() => navigateToTraining(training.name, TrainingType.All)}>\n                                    Start training\n                                </CButton>\n\n                                <CButton color=\"primary\"\n                                         onClick={() => navigateToTraining(training.name, TrainingType.OnlyNew)}>\n                                    Only learn new terms\n                                </CButton>\n\n                                <CButton color=\"primary\"\n                                         onClick={() => navigateToTraining(training.name, TrainingType.OnlyRepeat)}>\n                                    Only repeat terms\n                                </CButton>\n                            </>\n                        ) : termsToLearn > 0 ? (\n                            <CButton color=\"primary\"\n                                     onClick={() => navigateToTraining(training.name, TrainingType.OnlyNew)}>\n                                Learn new terms\n                            </CButton>\n                        ) : termsToRepeat > 0 ? (\n                            <CButton color=\"primary\"\n                                     onClick={() => navigateToTraining(training.name, TrainingType.OnlyRepeat)}>\n                                Repeat terms\n                            </CButton>\n                        ) : (\n                            <CButton color=\"primary\" disabled>\n                                Next training in {formatDistance(Date.now(), new Date(Date.now() + minimalTimeToUpdate), {includeSeconds: false})}\n                            </CButton>\n                        )}\n\n                    </div>\n                </CCardBody>\n            </CCard>\n        </CCol>\n)\n}","import {TrainingDefinition} from \"../model/TrainingDefinition\";\nimport {LepeatProfile} from \"../model/LepeatProfile\";\nimport {doNeedToTrain} from \"./TrainingService\";\nimport {Status, TermTrainingProgress} from \"../model/TrainingProgress\";\nimport {Term} from \"../model/Term\";\n\nexport function getTrainingStatistics(trainingDefinition: TrainingDefinition, profile: LepeatProfile) {\n    const overallStatistics = new Array<number>(trainingDefinition.repetitionIntervals.length + 1).fill(0);\n    const thisTimeStatistics = new Array<number>(trainingDefinition.repetitionIntervals.length + 1).fill(0);\n    let minimalTimeToUpdate = Number.MAX_SAFE_INTEGER;\n\n    const trainingProgress = profile.trainingProgresses.get(trainingDefinition);\n    const currentTime = Date.now();\n\n    const progressForCurrentTraining = trainingProgress?.progress ?? new Map<Term, TermTrainingProgress>();\n    const matchingTerms = profile.terms\n        .filter(t => !t.isBacklog)\n        .filter(term => trainingDefinition.configuration.has(term.termDefinition));\n\n    for (const term of matchingTerms) {\n        const termProgress = progressForCurrentTraining.get(term);\n        if (!termProgress) {\n            overallStatistics[0] += 1;\n            thisTimeStatistics[0] += 1;\n        } else {\n            const {doNeed, remainingDelayBeforeStart} = doNeedToTrain(termProgress, trainingDefinition, currentTime);\n            switch (termProgress.status) {\n                case Status.Learning:\n                case Status.Relearning:\n                    updateStatistics(0, doNeed, remainingDelayBeforeStart);\n                    break;\n                case Status.Repetition:\n                    const iteration = Math.min(Math.max(0, termProgress.iterationNumber), overallStatistics.length - 2);\n                    updateStatistics(iteration + 1, doNeed, remainingDelayBeforeStart);\n                    break;\n            }\n        }\n    }\n\n    return {overallStatistics, thisTimeStatistics, minimalTimeToUpdate};\n\n    function updateStatistics(iteration: number, doNeed: boolean, remainingDelayBeforeStart: number) {\n        overallStatistics[iteration] += 1;\n\n        if (doNeed) {\n            thisTimeStatistics[iteration] += 1;\n        } else {\n            minimalTimeToUpdate = Math.min(minimalTimeToUpdate, remainingDelayBeforeStart);\n        }\n    }\n}","import React, {useContext} from 'react'\n\nimport {CRow,} from '@coreui/react'\nimport ProfileContext from \"../../contexts/ProfileContext\";\nimport {TrainingCard} from \"./TrainingCard\";\n\nconst Dashboard = () => {\n  const { profile } = useContext(ProfileContext);\n  return (\n    <>\n      <CRow className=\"mb-4\" xs={{ gutter: 4 }}>\n        {profile.trainingDefinitions.map((training) => {\n            return <TrainingCard training={training} profile={profile} key={training.id} />\n        })}\n      </CRow>\n    </>\n  )\n}\n\nexport default Dashboard\n","import {LepeatProfile} from \"../model/LepeatProfile\";\nimport {TrainingDefinition} from \"../model/TrainingDefinition\";\nimport {Status, TermTrainingProgress} from \"../model/TrainingProgress\";\nimport {markProfileDirty} from \"./Persistence\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nconst isDebug = process.env.REACT_APP_IS_DEBUG === 'true';\n\nexport enum TrainingType {\n    OnlyNew = 'onlyNew',\n    OnlyRepeat = 'onlyRepeat',\n    All = 'all'\n}\n\nexport function updateTermProgressEasy(termProgress: TermTrainingProgress, profile : LepeatProfile) {\n    switch (termProgress.status) {\n        case Status.Relearning:\n            throw new Error(\"Unexpected `easy` action for relearning step\");\n        case Status.Learning:\n            termProgress.status = Status.Repetition;\n            termProgress.iterationNumber = 0;\n            break;\n        case Status.Repetition:\n            termProgress.iterationNumber += 2;\n            break;\n        default:\n            throw new Error(`Unknown status: ${termProgress.status}`);\n    }\n\n    termProgress.lastEditDate = Date.now();\n    markProfileDirty(profile);\n}\n\nexport function updateTermProgressHard(termProgress: TermTrainingProgress, profile : LepeatProfile) {\n    if (termProgress.status === Status.Relearning){\n        throw new Error(\"Unexpected `hard` action for relearning step\");\n    }\n\n    termProgress.lastEditDate = Date.now();\n    markProfileDirty(profile);\n}\n\nexport function updateTermProgressKnown(termProgress: TermTrainingProgress, trainingDefinitions: TrainingDefinition,profile : LepeatProfile) {\n    const currentIteration = termProgress.iterationNumber;\n\n    switch (termProgress.status) {\n        case Status.Relearning:\n            termProgress.status = Status.Repetition;\n            termProgress.iterationNumber = Math.max(0, termProgress.iterationNumber - 1); \n            break;\n        case Status.Learning:\n            if (currentIteration + 1 >= trainingDefinitions.learningIntervals.length){\n                termProgress.status = Status.Repetition;\n                termProgress.iterationNumber = 0;\n            } else {\n                termProgress.iterationNumber += 1;\n            }\n            break;\n        case Status.Repetition:\n            termProgress.iterationNumber += 1;\n            break;\n        default:\n            throw new Error(`Unknown status: ${termProgress.status}`);\n    }\n\n    termProgress.lastEditDate = Date.now();\n    markProfileDirty(profile);\n}\n\nexport function updateTermProgressDontKnown(termProgress: TermTrainingProgress, profile : LepeatProfile) {\n    switch (termProgress.status) {\n        case Status.Relearning:\n            termProgress.status = Status.Learning;\n            termProgress.iterationNumber = 0;\n            break;\n        case Status.Learning:\n            termProgress.iterationNumber = 0;\n            break;\n        case Status.Repetition:\n            termProgress.status = Status.Relearning;\n            break;\n        default:\n            throw new Error(`Unknown status: ${termProgress.status}`);\n    }\n\n    termProgress.lastEditDate = Date.now();\n    markProfileDirty(profile);\n}\n\nexport function copyTermTrainingProgress(termTrainingProgress: TermTrainingProgress) {\n    return {...termTrainingProgress};\n}\nexport function updateTermTrainingProgress(source : TermTrainingProgress, target: TermTrainingProgress, profile : LepeatProfile) {\n    target.status = source.status;\n    target.lastEditDate = source.lastEditDate;\n    target.iterationNumber = source.iterationNumber;\n    markProfileDirty(profile);\n}\n\nexport function getTermsToTrain(profile: LepeatProfile, trainingDefinition: TrainingDefinition, trainingType: TrainingType) {\n    let trainingProgress = profile.trainingProgresses.get(trainingDefinition);\n    if (!trainingProgress) {\n        trainingProgress = {progress: new Map()};\n        profile.trainingProgresses.set(trainingDefinition, trainingProgress);\n    }\n\n    let progressForCurrentTraining = trainingProgress.progress;\n    let currentTime = Date.now();\n\n    return profile.terms\n        .filter(t => !t.isBacklog)\n        .filter(term => trainingDefinition.configuration.has(term.termDefinition))\n        .map(value => {\n            let termProgress = progressForCurrentTraining.get(value);\n            if (!termProgress) {\n                termProgress = {\n                    id: uuidv4(),\n                    status: Status.Learning,\n                    term: value,\n                    iterationNumber: 0,\n                    lastEditDate: undefined\n                };\n\n                progressForCurrentTraining.set(value, termProgress);\n            }\n            return termProgress;\n        })\n        .filter(progress => {\n            switch (trainingType) {\n              case TrainingType.OnlyNew:\n                return progress.status === Status.Learning || progress.status === Status.Relearning;\n              case TrainingType.OnlyRepeat:\n                return progress.status === Status.Repetition;\n            }\n            return true;\n        })\n        .filter(progress => doNeedToTrain(progress, trainingDefinition, currentTime).doNeed);\n}\n\nexport function doNeedToTrain(progress: TermTrainingProgress, trainingDefinition: TrainingDefinition, currentTime: number): {\n    doNeed: boolean;\n    remainingDelayBeforeStart: number\n} {\n    const lastTrainingDate = progress.lastEditDate;\n    if (!lastTrainingDate) {\n        return {doNeed: true, remainingDelayBeforeStart: 0};\n    }\n    let interval = getInterval(trainingDefinition, progress);\n\n    const nextTrainDateForTerm = lastTrainingDate + interval;\n    const remainingDelayBeforeStart = nextTrainDateForTerm - currentTime;\n    const doNeedTrain = remainingDelayBeforeStart <= 0;\n    return {doNeed: doNeedTrain, remainingDelayBeforeStart};\n}\n\nfunction getInterval(trainingDefinition: TrainingDefinition, progress: TermTrainingProgress) {\n    switch (progress.status) {\n        case Status.Relearning:\n            return fromMinutes(trainingDefinition.learningIntervals[trainingDefinition.learningIntervals.length - 1] ?? 0);\n        case Status.Learning:\n            return fromMinutes(getIntervalSafe(trainingDefinition.learningIntervals, progress.iterationNumber));\n        case Status.Repetition:\n            return fromHours(getIntervalSafe(trainingDefinition.repetitionIntervals, progress.iterationNumber));\n    }\n}\n\nfunction fromMinutes(number: number) {\n    if (isDebug){\n        return 1000 * 30;\n    }\n\n    return number * 1000 * 60;\n}\n\nfunction fromHours(number: number) {\n    if (isDebug){\n        return 1000 * 60;\n    }\n\n    return number * 1000 * 60 * 60 * 24;\n}\n\nfunction getIntervalSafe(array: number[], iteration: number): number {\n    if (array.length === 0) {\n        return 0;\n    }\n\n    if (iteration < 0) {\n        return array[0];\n    } else if (iteration >= array.length) {\n        return array[array.length - 1];\n    } else {\n        return array[iteration];\n    }\n}"],"names":["printTermWord","count","concat","TrainingCard","_ref","training","profile","navigate","useNavigate","navigateToTraining","name","trainingType","state","trainingName","overallStatistics","thisTimeStatistics","minimalTimeToUpdate","trainingDefinition","_trainingProgress$pro","Array","repetitionIntervals","length","fill","Number","MAX_SAFE_INTEGER","trainingProgress","trainingProgresses","get","currentTime","Date","now","progressForCurrentTraining","progress","Map","matchingTerms","terms","filter","t","isBacklog","term","configuration","has","termDefinition","termProgress","doNeed","remainingDelayBeforeStart","doNeedToTrain","status","Status","Learning","Relearning","updateStatistics","Repetition","Math","min","max","iterationNumber","iteration","getTrainingStatistics","termsToRepeat","slice","reduce","sum","value","allTermsCount","num","termsToLearn","forceUpdate","useReducer","x","useEffect","timerId","setTimeout","clearTimeout","_jsx","CCol","sm","xl","xxl","children","_jsxs","CCard","className","CCardHeader","CChartRadar","data","labels","from","_","i","datasets","label","backgroundColor","borderColor","pointBackgroundColor","pointBorderColor","pointHighlightFill","pointHighlightStroke","options","scales","r","ticks","showLabelBackdrop","precision","z","CCardBody","CCardTitle","CCardText","_Fragment","CButton","color","onClick","TrainingType","All","OnlyNew","OnlyRepeat","disabled","formatDistance","includeSeconds","Dashboard","useContext","ProfileContext","CRow","xs","gutter","trainingDefinitions","map","id","isDebug","process","updateTermProgressEasy","Error","lastEditDate","markProfileDirty","updateTermProgressHard","updateTermProgressKnown","currentIteration","learningIntervals","updateTermProgressDontKnown","copyTermTrainingProgress","termTrainingProgress","updateTermTrainingProgress","source","target","getTermsToTrain","set","uuidv4","undefined","lastTrainingDate","interval","_trainingDefinition$l","fromMinutes","getIntervalSafe","number","fromHours","getInterval","array"],"sourceRoot":""}